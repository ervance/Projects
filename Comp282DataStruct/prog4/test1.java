/*  My output

Testing Fearless Leader's program.
QS: book partition, random pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: 2ptr partition, random pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: book partition, lf pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: 2ptr partition, lf pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: book partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: 2ptr partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: book partition, lf pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: 2ptr partition, lf pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Almost QS book partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Almost QS 2ptr partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
HeapSortTD: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
HeapSortBU: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Quicksort 3 Partition, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Quicksort 3 Partition cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Bigger, QS: book partition, random pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: 2ptr partition, random pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: book partition, lf pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: 2ptr partition, lf pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: book partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: 2ptr partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: book partition, lf pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: 2ptr partition, lf pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Almost QS book partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Almost QS 2ptr partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, HeapSortTD:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, HeapSortBU:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Quicksort 3 Partition, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Quicksort 3 Partition cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.

Testing Fearless Leader's sorts on a huge array.

Java's QuickSort on random data runs in 3.581 seconds.
Java's QuickSort on the test sets runs in 1.112 seconds.


Fearless Leader's QS: book partition, random pivot, cutoff=50
    on all random values runs in 3.653 seconds.      Java Ratio = 1.02

Fearless Leader's QS: 2ptr partition, random pivot, cutoff=50
    on all random values runs in 3.667 seconds.      Java Ratio = 1.02
    on the test sets runs in 1.883 seconds.          Java Ratio = 1.69

Fearless Leader's QS: book partition, lf pivot, cutoff=50
    on all random values runs in 3.570 seconds.      Java Ratio = 0.99

Fearless Leader's QS: 2ptr partition, lf pivot, cutoff=50
    on all random values runs in 3.848 seconds.      Java Ratio = 1.07

Fearless Leader's QS: book partition, random pivot, cutoff=2
    on all random values runs in 4.936 seconds.      Java Ratio = 1.37

Fearless Leader's QS: 2ptr partition, random pivot, cutoff=2
    on all random values runs in 5.307 seconds.      Java Ratio = 1.48
    on the test sets runs in 3.237 seconds.          Java Ratio = 2.91

Fearless Leader's QS: book partition, lf pivot, cutoff=2
    on all random values runs in 4.348 seconds.      Java Ratio = 1.21

Fearless Leader's QS: 2ptr partition, lf pivot, cutoff=2
    on all random values runs in 4.671 seconds.      Java Ratio = 1.30

Fearless Leader's Almost QS book partition, random pivot, cutoff=2
    on all random values runs in 4.624 seconds.      Java Ratio = 1.29

Fearless Leader's Almost QS 2ptr partition, random pivot, cutoff=2
    on all random values runs in 5.454 seconds.      Java Ratio = 1.52

Fearless Leader's HeapSortTD
    on all random values runs in 7.764 seconds.      Java Ratio = 2.16

Fearless Leader's HeapSortBU
    on all random values runs in 7.595 seconds.      Java Ratio = 2.12

Fearless Leader's Quicksort 3 Partition, cutoff=2
    on all random values runs in 4.660 seconds.      Java Ratio = 1.30

Fearless Leader's Quicksort 3 Partition cutoff=50
    on all random values runs in 3.528 seconds.      Java Ratio = 0.98

Done testing Fearless Leader methods.

*/

import java.io.*; // for IOException
import java.util.Arrays; // to compare your sort against Java's

public class test1 {

	public static void main(String[] args) throws IOException {

		final int largeSize = 10000000;
		int[] number, goodone;
		int n, differ, sort, fill, i;
		boolean[] Sort_OK = { true, true, true, true, true, true, true, true,
				true, true, true, true, true, true };
		long before, after, yourtotal, javarandomtotal, javaothertotal;
		number = new int[20000];
		goodone = new int[20000];
		String[] SortType = {
				"QS: book partition, random pivot, cutoff=50",
				"QS: 2ptr partition, random pivot, cutoff=50",
				"QS: book partition, lf pivot, cutoff=50",
				"QS: 2ptr partition, lf pivot, cutoff=50",
				"QS: book partition, random pivot, cutoff=2",
				"QS: 2ptr partition, random pivot, cutoff=2",
				"QS: book partition, lf pivot, cutoff=2",
				"QS: 2ptr partition, lf pivot, cutoff=2",
				"Almost QS book partition, random pivot, cutoff=2",
				"Almost QS 2ptr partition, random pivot, cutoff=2", "HeapSortTD",
				"HeapSortBU", "Quicksort 3 Partition, cutoff=2",
				"Quicksort 3 Partition cutoff=50" };
		String[] FillType = { "Increasing", "Decreasing", "Random", "Constant",
				"Mids" };

		int numSorts = SortType.length;
		if (!ArraySorts.implemented3partition())
			numSorts -= 2;
		System.out.println("Testing " + ArraySorts.myName() + "'s program.");

		// First check to see if they sort small arrays properly
		for (sort = 0; sort < numSorts; sort++) {
			System.out.print(SortType[sort] + ": \n    ");
			for (n = 26; n >= 0 && Sort_OK[sort]; n--) {
				System.out.print(n + ".");

				for (fill = 0; fill < FillType.length && Sort_OK[sort]; fill++) {
					fillArray(fill, number, 0, n);
					for (i = 0; i < n; i++)
						goodone[i] = number[i];
					callSort(sort + 1, number, n);
					Arrays.sort(goodone, 0, n);
					differ = same(goodone, number, n);
					if (differ != -1) {
						System.out.println();
						System.out.println("*** " + FillType[fill]
								+ " sorting error: " + SortType[sort]
								+ ", position #" + differ);
						System.out.println("*** No more " + SortType[sort]
								+ "s will be tested.  Correct values and "
								+ ArraySorts.myName() + "'s values follow.");
						Sort_OK[sort] = false;
						mydisplay(goodone, n);
						mydisplay(number, n);
					}
				}
			}
			System.out.println();
		}

		// Now check larger arrays
		for (sort = 0; sort < numSorts; sort++) {
			System.out.print("Bigger, " + SortType[sort] + ":\n    ");
			for (n = 100; n <= 20000 && Sort_OK[sort]; n = n + 531) {
				System.out.print(n + ".");
				if (n == 8596 || n == 16030) {
					System.out.println();
					System.out.print("    ");
				}

				for (fill = 0; fill < FillType.length && Sort_OK[sort]; fill++) {
					fillArray(fill, number, 1, n);
					for (i = 0; i < n; i++)
						goodone[i] = number[i];
					callSort(sort + 1, number, n);
					Arrays.sort(goodone, 0, n);
					differ = same(goodone, number, n);
					if (differ != -1) {
						System.out.println();
						System.out.println("*** " + FillType[fill]
								+ " sorting error: " + SortType[sort]
								+ ", position #" + differ);
						System.out.println("*** No more " + SortType[sort]
								+ "s will be tested.  Correct values and "
								+ ArraySorts.myName() + "'s values follow.");
						Sort_OK[sort] = false;
					}
				}
			}
			System.out.println(" done.");
		}
		System.out.println();

		// Now see how fast your sorts really are
		System.out.println("Testing " + ArraySorts.myName()
				+ "'s sorts on a huge array.");
		number = new int[largeSize];
		javarandomtotal = 0;
		for (fill = 1; fill < 5; fill++) {
			fillArray(2, number, 1, largeSize);
			before = System.currentTimeMillis();
			Arrays.sort(number);
			after = System.currentTimeMillis();
			javarandomtotal = javarandomtotal + after - before;
		}
		System.out.println("\nJava's QuickSort on random data runs in "
				+ javarandomtotal / 1000 + "." + millis(javarandomtotal % 1000)
				+ " seconds.");

		javaothertotal = 0;
		for (fill = 1; fill < 5; fill++) {
			fillArray(fill, number, 1, largeSize);
			before = System.currentTimeMillis();
			Arrays.sort(number);
			after = System.currentTimeMillis();
			javaothertotal = javaothertotal + after - before;
		}
		System.out.println("Java's QuickSort on the test sets runs in "
				+ javaothertotal / 1000 + "." + millis(javaothertotal % 1000)
				+ " seconds.");
		System.out.println();

		for (int sortNum = 0; sortNum < numSorts; sortNum++) {
			if (Sort_OK[sortNum]) {
				yourtotal = 0;
				for (fill = 1; fill < 5; fill++) {
					fillArray(2, number, 1, largeSize);
					before = System.currentTimeMillis();
					callSort(sortNum + 1, number, largeSize);
					after = System.currentTimeMillis();
					yourtotal = yourtotal + after - before;
				}
				System.out.print("\n" + ArraySorts.myName() + "'s "
						+ SortType[sortNum]
						+ "\n    on all random values runs in " + yourtotal
						/ 1000 + "." + millis(yourtotal % 1000) + " seconds.");
				System.out
						.println("      Java Ratio = "
								+ (yourtotal / javarandomtotal)
								+ "."
								+ hundreds((int) (((float) (yourtotal)
										/ javarandomtotal - (yourtotal / javarandomtotal)) * 100)));
				if (sortNum == 1 || sortNum == 5) {
					yourtotal = 0;
					for (fill = 1; fill < 5; fill++) {
						fillArray(fill, number, 1, largeSize);
						before = System.currentTimeMillis();
						callSort(sortNum + 1, number, largeSize);
						after = System.currentTimeMillis();
						yourtotal = yourtotal + after - before;
					}
					System.out.print("    on the test sets runs in "
							+ yourtotal / 1000 + "." + millis(yourtotal % 1000)
							+ " seconds.");
					System.out
							.print("          Java Ratio = "
									+ (yourtotal / javaothertotal)
									+ "."
									+ hundreds((int) (((float) (yourtotal)
											/ javaothertotal - (yourtotal / javaothertotal)) * 100)));
					System.out.println();
				}
			} else {
				System.out.println(ArraySorts.myName() + "'s "
						+ SortType[sortNum] + " not tested.");
				System.out.println();
			}
		}
		System.out.println("\nDone testing " + ArraySorts.myName()
				+ " methods.");
	}

	private static void callSort(int which, int[] a, int n) {
		if (which == 1)
			ArraySorts.QuickSort1(a, n, 50);
		else if (which == 2)
			ArraySorts.QuickSort2(a, n, 50);
		else if (which == 3)
			ArraySorts.QuickSort3(a, n, 50);
		else if (which == 4)
			ArraySorts.QuickSort4(a, n, 50);
		else if (which == 5)
			ArraySorts.QuickSort1(a, n, 2);
		else if (which == 6)
			ArraySorts.QuickSort2(a, n, 2);
		else if (which == 7)
			ArraySorts.QuickSort3(a, n, 2);
		else if (which == 8)
			ArraySorts.QuickSort4(a, n, 2);
		else if (which == 9)
			ArraySorts.AlmostQS1(a, n, 2);
		else if (which == 10)
			ArraySorts.AlmostQS2(a, n, 2);
		else if (which == 11)
			ArraySorts.HeapSortTD(a, n);
		else if (which == 12)
			ArraySorts.HeapSortBU(a, n);
		else if (which == 13)
			ArraySorts.QuickSort_3Partition(a, n, 2);
		else if (which == 14)
			ArraySorts.QuickSort_3Partition(a, n, 50);
		else
			System.out.println("No such sort " + which + ".");
	}

	private static void fillArray(int fillNumber, int[] number, int BigorSmall,
			int n) {
		if (fillNumber == 0)
			fillIncreasing(number, n);
		else if (fillNumber == 1)
			fillDecreasing(number, n);
		else if (fillNumber == 2) {
			if (BigorSmall == 0)
				fillRandomSmall(number, n);
			else
				fillRandomBig(number, n);
		} else if (fillNumber == 3)
			fillConstant(number, n);
		else if (fillNumber == 4)
			fillMids(number, n);
		else
			System.out.println("No such filling scheme.");
	}

	public static int same(int[] a, int[] b, int n) {
		int result = -1;
		for (int i = 0; (i < n) && (result == -1); i++)
			if (a[i] != b[i])
				result = i;
		return result;
	}

	public static void mydisplay(int[] a, int n) {
		for (int i = 0; i < n; i++)
			System.out.print(a[i] + " ");
		System.out.println();
	}

	public static void fillMids(int[] a, int n) {
		fillMids(a, 0, n - 1, 0);
	}

	private static void fillMids(int[] a, int lf, int rt, int ct) {

		while (lf <= rt) {
			a[lf] = ct;
			ct++;
			lf++;
			a[rt] = ct;
			ct++;
			rt--;
		}
	}

	public static void fillConstant(int a[], int n) {
		int inc = n / Math.max(1, (int) Math.log((double) n));
		for (int i = 0; i < n; i++) {
			a[i] = 52;
		}
		for (int i = 0; i < n; i += inc) {
			if (i % 2 == 0)
				a[i] = 51;
			else
				a[i] = 53;
		}
	}

	public static void fillIncreasing(int[] a, int n) {
		for (int i = 0; i < n; i++)
			a[i] = i;
		if (n > 2) {
			a[n - 2] = 2;
			a[1] = n - 2;
		}
	}

	public static void fillDecreasing(int[] a, int n) {
		for (int i = 0; i < n; i++)
			a[i] = n - i - 1;
		if (n > 2) {
			a[n - 2] = n - 2;
			a[1] = 1;
		}
	}

	public static void fillRandomSmall(int a[], int n) {
		for (int i = 0; i < n; i++)
			a[i] = (int) (Math.random() * n);
	}

	public static void fillRandomBig(int a[], int n) {
		for (int i = 0; i < n; i++)
			a[i] = (int) (Math.random() * n * 10);
	}

	public static String millis(long n) {
		String rtn;
		if (n < 10)
			rtn = "00" + n;
		else if (n < 100)
			rtn = "0" + n;
		else
			rtn = String.valueOf(n);
		return rtn;
	}

	public static String hundreds(long n) {
		String rtn;
		if (n < 10)
			rtn = "0" + n;
		else
			rtn = String.valueOf(n);
		return rtn;
	}

}